<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Planificador Interactivo + Juegos (Dark Modern)</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600;700&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

        :root {
            /* Paleta de Colores Oscuros */
            --color-background: #1a1a1a; /* Negro muy oscuro */
            --color-surface: #2c2c2c;    /* Gris oscuro para elementos principales */
            --color-text-light: #e0e0e0; /* Texto claro */
            --color-text-medium: #b0b0b0; /* Texto secundario */
            --color-border: #444;       /* Borde suave */

            /* Acentos de color */
            --color-accent-blue: #00bfff; /* Azul eléctrico */
            --color-accent-green: #39ff14; /* Verde neón */
            --color-accent-red: #ff4500;  /* Rojo vibrante */
            --color-accent-purple: #9300ff; /* Púrpura */

            /* Sombras y radios */
            --sombra-suave: 0 4px 15px rgba(0, 0, 0, 0.3);
            --sombra-profunda: 0 8px 25px rgba(0, 0, 0, 0.6);
            --borde-radio: 12px;

            /* Colores específicos de los juegos (adaptados al tema oscuro) */
            --snake-bg: #103312; /* Verde oscuro para snake */
            --snake-color: var(--color-accent-green); /* Serpiente verde neón */
            --apple-color: var(--color-accent-red);   /* Manzana roja */
            --apple-leaf-color: #6B8E23; /* Verde oliva para la hoja */

            --tetris-bg: #1a1a1a;
            --tetris-border: var(--color-border);
            --tetris-text: var(--color-text-light);
            --tetris-score-bg: #333;
        }

        * { box-sizing: border-box; margin: 0; padding: 0; }

        body {
            font-family: 'Poppins', sans-serif;
            background-color: var(--color-background);
            color: var(--color-text-light);
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            padding: 20px;
            overflow-x: hidden; /* Evita scroll horizontal en móviles */
        }

        .main-wrapper {
            width: 100%;
            max-width: 1200px;
            display: flex;
            align-items: flex-start;
            gap: 20px;
        }

        .planner-wrapper {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .calendario-container {
            width: 100%;
            background: var(--color-surface);
            border-radius: var(--borde-radio);
            box-shadow: var(--sombra-profunda);
            overflow: hidden;
            border: 1px solid var(--color-border);
        }
        
        .calendario-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 25px;
            background: linear-gradient(135deg, #303030, #1f1f1f); /* Gradiente oscuro */
            color: var(--color-text-light);
            border-bottom: 1px solid #3a3a3a;
        }
        
        .calendario-header h1 { font-size: 1.5rem; }

        .calendario-grid {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 1px;
            background-color: #3a3a3a; /* Separadores */
        }

        .dia-semana, .dia-mes { display: flex; background-color: var(--color-surface); }
        .dia-semana { 
            justify-content: center; 
            align-items: center; 
            padding: 10px 5px; 
            font-size: 0.8rem; 
            font-weight: 600; 
            color: var(--color-text-medium);
            background-color: #252525;
        }
        .dia-mes { 
            min-height: 80px; 
            cursor: pointer; 
            transition: transform 0.2s ease, box-shadow 0.2s ease, background-color 0.2s ease; 
            position: relative; 
            flex-direction: column; 
            justify-content: space-between; 
            padding: 5px; 
            border: 1px solid transparent; /* Para el efecto hover */
        }
        .dia-mes:not(.otro-mes):hover { 
            transform: translateY(-3px) scale(1.02); 
            box-shadow: var(--sombra-suave); 
            background-color: #3a3a3a;
            border-color: var(--color-accent-blue);
            z-index: 10; 
        }
        .dia-mes.otro-mes { 
            color: #777; 
            background-color: #202020; 
            cursor: default; 
            border-color: transparent;
        }
        .numero-dia { 
            font-size: 0.9rem; 
            align-self: flex-end; 
            font-weight: 500;
            color: var(--color-text-light);
        }
        .plan-preview { 
            position: absolute; 
            top:0; left:0; 
            width: 100%; height: 100%; 
            background-size: cover; 
            background-position: center; 
            z-index: -1; 
            filter: brightness(0.5); /* Oscurece la imagen para que el texto sea legible */
            opacity: 0.6;
        }
        .dia-mes.con-plan .numero-dia { 
            color: white; 
            text-shadow: 0 1px 3px rgba(0,0,0,0.8); 
            font-weight: bold; 
        }

        /* --- CONTROLES Y JUEGO --- */
        .game-selection-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            padding: 20px;
            width: 100%;
            flex-shrink: 0;
            text-align: center;
            background: var(--color-surface);
            border-radius: var(--borde-radio);
            box-shadow: var(--sombra-suave);
            border: 1px solid var(--color-border);
        }

        .game-selection-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap; 
        }

        .game-selection-buttons button {
            font-family: 'Press Start 2P', cursive;
            background: #444;
            color: var(--color-text-light);
            border: none;
            padding: 15px 25px;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: var(--sombra-suave);
            flex: 1 1 auto; 
            min-width: 150px;
            border: 1px solid var(--color-border);
        }

        .game-selection-buttons button.snake-btn {
            background: var(--snake-color); /* Verde neón */
            color: var(--color-background);
            text-shadow: 1px 1px 0 #000;
            border-color: var(--snake-color);
        }
        .game-selection-buttons button.tetris-btn {
            background: var(--color-accent-blue); /* Azul eléctrico */
            color: var(--color-background);
            text-shadow: 1px 1px 0 #000;
            border-color: var(--color-accent-blue);
        }

        .game-selection-buttons button:hover { 
            transform: translateY(-5px) scale(1.05); 
            box-shadow: var(--sombra-profunda); 
            filter: brightness(1.2);
        }
        
        /* Contenedores de juegos individuales */
        .game-container {
            display: none; 
            flex-direction: column;
            align-items: center;
            gap: 15px;
            padding: 20px;
            background: var(--color-surface);
            border-radius: var(--borde-radio);
            box-shadow: var(--sombra-profunda);
            width: 440px;
            flex-shrink: 0;
            margin: 0 auto;
            border: 1px solid var(--color-border);
        }
        
        .back-btn {
            background: #555;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            margin-bottom: 15px;
            border: 1px solid #666;
        }
        .back-btn:hover {
            background: #6a6a6a;
            transform: translateY(-2px);
            box-shadow: var(--sombra-suave);
        }

        /* SNAKE STYLES */
        #snake-game-board {
            border: 5px solid var(--snake-color);
            background-color: var(--snake-bg);
        }

        .game-info {
            font-family: 'Press Start 2P', cursive;
            color: var(--snake-color);
            font-size: 1.2rem;
            text-align: center;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }
        .game-over {
            position: absolute;
            color: var(--apple-color);
            font-family: 'Press Start 2P', cursive;
            font-size: 2rem;
            text-align: center;
            display: none;
            text-shadow: 3px 3px 0 #000;
        }
        
        .snake-mobile-controls {
            display: none;
            grid-template-areas: ". up ." "left . right" ". down .";
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            width: 100%;
            max-width: 300px;
            margin-top: 20px;
        }

        .snake-mobile-controls button {
            background: var(--snake-color);
            color: var(--color-background);
            border: none;
            border-radius: 50%;
            padding: 20px;
            font-size: 1.2rem;
            font-weight: bold;
            cursor: pointer;
            box-shadow: var(--sombra-suave);
            transition: all 0.2s ease;
            -webkit-tap-highlight-color: transparent;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }
        .snake-mobile-controls button:active {
            transform: scale(0.9);
            filter: brightness(0.8);
        }
        .snake-mobile-controls button.up { grid-area: up; }
        .snake-mobile-controls button.down { grid-area: down; }
        .snake-mobile-controls button.left { grid-area: left; }
        .snake-mobile-controls button.right { grid-area: right; }

        /* TETRIS STYLES */
        #tetris-game-container {
            background: var(--tetris-bg);
            border: 5px solid var(--tetris-border);
            color: var(--tetris-text);
            font-family: 'Press Start 2P', cursive;
            position: relative;
        }
        #tetris-canvas {
            background: #000;
            border: 2px solid var(--tetris-border);
            display: block; 
            margin: 0 auto;
        }
        .tetris-info {
            display: flex;
            justify-content: space-around;
            width: 100%;
            margin-top: 10px;
            font-size: 0.9rem;
        }
        .tetris-info div {
            padding: 8px 12px;
            background: var(--tetris-score-bg);
            border-radius: 8px;
            box-shadow: inset 0 0 5px rgba(0,0,0,0.5);
        }
        .tetris-game-over-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 2.5rem;
            color: var(--color-accent-red);
            text-shadow: 4px 4px 0 #000;
            display: none;
            text-align: center;
            line-height: 1.2;
        }
        .tetris-mobile-controls {
            display: none; 
            width: 100%;
            margin-top: 15px;
            gap: 10px;
            justify-content: center;
        }
        .tetris-mobile-controls button {
            background: var(--color-accent-blue);
            color: var(--color-background);
            border: none;
            border-radius: 10px;
            padding: 15px;
            font-size: 1.5rem;
            font-weight: bold;
            cursor: pointer;
            box-shadow: var(--sombra-suave);
            transition: background 0.2s ease, transform 0.2s ease;
            -webkit-tap-highlight-color: transparent; 
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }
        .tetris-mobile-controls button:active {
            transform: scale(0.95);
            filter: brightness(0.8);
        }
        .tetris-control-row {
            display: flex;
            justify-content: center;
            gap: 10px;
            width: 100%;
        }


        /* --- MODALES --- */
        .modal-background { 
            position: fixed; 
            top: 0; left: 0; 
            width: 100%; height: 100%; 
            background-color: rgba(0, 0, 0, 0.85); 
            backdrop-filter: blur(5px);
            display: flex; 
            justify-content: center; 
            align-items: center; 
            opacity: 0; 
            visibility: hidden; 
            transition: opacity 0.4s ease; 
            z-index: 1000; 
        }
        .modal-background.visible { opacity: 1; visibility: visible; }
        .modal-content { 
            background: var(--color-surface); 
            border-radius: var(--borde-radio); 
            box-shadow: var(--sombra-profunda); 
            border: 1px solid var(--color-border);
            width: 90%; 
            max-width: 500px; 
            transform: scale(0.9); 
            transition: transform 0.4s cubic-bezier(0.18, 0.89, 0.32, 1.28); 
            color: var(--color-text-light);
        }
        .modal-background.visible .modal-content { transform: scale(1); }
        .modal-header { 
            display: flex; 
            justify-content: space-between; 
            align-items: center; 
            padding: 20px 25px; 
            border-bottom: 1px solid #3a3a3a; 
        }
        .modal-header h2 { font-size: 1.2rem; color: var(--color-text-light); }
        .modal-close { 
            background: transparent; 
            border: none; 
            font-size: 1.8rem; 
            cursor: pointer; 
            transition: transform 0.3s ease; 
            color: var(--color-text-medium);
        }
        .modal-close:hover { transform: rotate(90deg) scale(1.1); color: var(--color-accent-red); }
        
        /* Modal Edición */
        #editModal .modal-body { padding: 25px; }
        .file-upload-wrapper { 
            border: 2px dashed #666; 
            border-radius: 10px; 
            padding: 20px; 
            text-align: center; 
            cursor: pointer; 
            transition: background-color 0.3s, border-color 0.3s; 
            margin-bottom: 15px; 
            color: var(--color-text-medium);
        }
        .file-upload-wrapper:hover { 
            background-color: #3a3a3a; 
            border-color: var(--color-accent-blue);
            color: var(--color-text-light);
        }
        #imageUpload { display: none; }
        #imagePreview { max-width: 100%; max-height: 150px; border-radius: 5px; margin-top: 15px; border: 1px solid #555; }
        #planText { 
            width: 100%; 
            padding: 10px; 
            border-radius: 8px; 
            border: 1px solid #666; 
            min-height: 100px; 
            background-color: #333;
            color: var(--color-text-light);
            resize: vertical;
        }
        #planText::placeholder { color: #999; }
        
        /* Modal Visualización */
        #viewModal .modal-content { max-width: 600px; padding: 0; overflow: hidden; }
        .view-image { 
            width: 100%; 
            height: 250px; 
            background-size: cover; 
            background-position: center; 
            border-bottom: 1px solid #3a3a3a;
        }
        .view-text { padding: 25px; white-space: pre-wrap; color: var(--color-text-light); }

        .modal-footer { 
            display: flex; 
            justify-content: space-between; 
            gap: 15px; 
            padding: 15px 25px; 
            background-color: #252525; 
            border-top: 1px solid #3a3a3a; 
        }
        .modal-footer button { 
            flex-grow: 1; 
            padding: 12px; 
            border: none; 
            border-radius: 8px; 
            font-weight: 600; 
            cursor: pointer; 
            transition: transform 0.2s, box-shadow 0.2s, filter 0.2s; 
            color: var(--color-background);
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }
        #guardarPlan { background: var(--color-accent-green); }
        #borrarPlan { background: var(--color-accent-red); }
        #editarPlan { background: var(--color-accent-blue); width: 100%; }

        .modal-footer button:hover {
            transform: translateY(-2px);
            box-shadow: var(--sombra-suave);
            filter: brightness(1.1);
        }

        /* --- RESPONSIVE DESIGN --- */
        @media (max-width: 900px) {
            .main-wrapper { flex-direction: column; }
            .game-container { width: 100%; }
        }
        @media (max-width: 600px) {
            body { padding: 10px; }
            .calendario-header { padding: 15px; }
            .calendario-header h1 { font-size: 1.2rem; }
            .dia-mes { min-height: 60px; font-size: 0.8rem; }
            .dia-semana { font-size: 0.7rem; }
            .game-selection-buttons button { padding: 10px 15px; font-size: 0.9rem; min-width: unset; }
            .tetris-game-over-text { font-size: 2rem; }
            .tetris-mobile-controls { display: flex; flex-direction: column; } 
            .tetris-mobile-controls button { padding: 12px; font-size: 1.2rem; }
            .snake-mobile-controls { display: grid; } /* Mostrar controles móviles de snake */
        }
    </style>
</head>
<body>

    <div class="main-wrapper">
        <div class="planner-wrapper">
            <div class="game-selection-wrapper">
                <div class="game-selection-buttons">
                    <button id="show-snake-btn" class="snake-btn">Jugar Snake</button>
                    <button id="show-tetris-btn" class="tetris-btn">Jugar Tetris</button>
                </div>
            </div>

            <div class="calendario-container">
                <div class="calendario-header">
                    <h1>Agosto 2025</h1>
                </div>
                <div class="calendario-grid">
                </div>
            </div>
        </div>

        <div id="snake-game-container" class="game-container">
            <button class="back-btn">Volver al Planificador</button>
            <div class="game-info">Puntaje: <span id="snake-score">0</span></div>
            <div style="position:relative;">
                <canvas id="snake-game-board" width="400" height="400"></canvas>
                <div class="game-over" id="snake-gameOverText">GAME OVER</div>
            </div>
            <div class="snake-mobile-controls">
                <button class="up" id="snake-up-btn">▲</button>
                <button class="left" id="snake-left-btn">◀</button>
                <button class="right" id="snake-right-btn">▶</button>
                <button class="down" id="snake-down-btn">▼</button>
            </div>
        </div>

        <div id="tetris-game-container" class="game-container">
            <button class="back-btn">Volver al Planificador</button>
            <div class="tetris-info">
                <div>SCORE: <span id="tetris-score">0</span></div>
                <div>LEVEL: <span id="tetris-level">1</span></div>
                <div>NEXT: <canvas id="tetris-next-piece-canvas" width="80" height="80"></canvas></div>
            </div>
            <canvas id="tetris-canvas" width="200" height="400"></canvas>
            <div class="tetris-game-over-text" id="tetris-gameOverText">GAME OVER<br>Presiona "R" para reiniciar</div>
            
            <div class="tetris-mobile-controls">
                <div class="tetris-control-row">
                    <button id="tetris-rotate-left">⤺</button>
                    <button id="tetris-rotate-right">⤻</button>
                </div>
                <div class="tetris-control-row">
                    <button id="tetris-move-left">◀</button>
                    <button id="tetris-soft-drop">▼</button>
                    <button id="tetris-move-right">▶</button>
                </div>
                <div class="tetris-control-row">
                    <button id="tetris-hard-drop">⬇</button>
                </div>
            </div>
        </div>
    </div>

    <div class="modal-background" id="editModal">
        <div class="modal-content">
            <div class="modal-header"><h2 id="editModalTitle"></h2><button class="modal-close">&times;</button></div>
            <form id="planForm">
                <div class="modal-body">
                    <label for="imageUpload" class="file-upload-wrapper">
                        <span>Haz clic para subir una imagen</span>
                        <input type="file" id="imageUpload" accept="image/*">
                        <img id="imagePreview" src="" alt="Vista previa de imagen" style="display:none;">
                    </label>
                    <textarea id="planText" placeholder="Describe tu plan..."></textarea>
                </div>
                <div class="modal-footer">
                    <button type="button" id="borrarPlan">Borrar</button>
                    <button type="submit" id="guardarPlan">Guardar</button>
                </div>
            </form>
        </div>
    </div>
    <div class="modal-background" id="viewModal">
        <div class="modal-content">
            <div class="modal-header"><h2 id="viewModalTitle"></h2><button class="modal-close">&times;</button></div>
            <div class="modal-body">
                <div class="view-image" id="viewImage"></div>
                <div class="view-text" id="viewText"></div>
            </div>
            <div class="modal-footer">
                <button type="button" id="editarPlan">Editar Plan</button>
            </div>
        </div>
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        // --- GESTIÓN DE VISTAS (PLANIFICADOR, SNAKE, TETRIS) ---
        const plannerContainer = document.querySelector('.calendario-container');
        const plannerWrapper = document.querySelector('.planner-wrapper');
        const snakeGameContainer = document.getElementById('snake-game-container');
        const tetrisGameContainer = document.getElementById('tetris-game-container');
        
        const showSnakeBtn = document.getElementById('show-snake-btn');
        const showTetrisBtn = document.getElementById('show-tetris-btn');

        const backButtons = document.querySelectorAll('.back-btn');

        let currentGame = 'planner'; 

        const showView = (view) => {
            // Ocultar todos los contenedores primero
            plannerWrapper.style.display = 'none';
            snakeGameContainer.style.display = 'none';
            tetrisGameContainer.style.display = 'none';
            
            // Detener bucles de juego
            cancelAnimationFrame(snakeGameLoop); 
            clearInterval(tetrisGameLoop); 

            // Mostrar la vista correcta
            if (view === 'planner') {
                plannerWrapper.style.display = 'flex';
            } else if (view === 'snake') {
                snakeGameContainer.style.display = 'flex';
                iniciarSnakeGame();
            } else if (view === 'tetris') {
                tetrisGameContainer.style.display = 'flex';
                iniciarTetrisGame();
            }
            currentGame = view;
        };
        
        showSnakeBtn.addEventListener('click', () => showView('snake'));
        showTetrisBtn.addEventListener('click', () => showView('tetris'));

        backButtons.forEach(btn => {
            btn.addEventListener('click', () => showView('planner'));
        });

        // --- LÓGICA DEL PLANIFICADOR ---
        const calendarioGrid = document.querySelector('.calendario-grid');
        const editModal = document.getElementById('editModal');
        const viewModal = document.getElementById('viewModal');
        const planForm = document.getElementById('planForm');
        const imageUpload = document.getElementById('imageUpload');
        const imagePreview = document.getElementById('imagePreview');
        const borrarPlanBtn = document.getElementById('borrarPlan');
        
        let diaSeleccionado = null;
        let imagenBase64 = null;
        const mesAnioActual = 'agosto-2025';

        const generarCalendario = () => {
            const diasSemanas = ['Dom', 'Lun', 'Mar', 'Mié', 'Jue', 'Vie', 'Sáb'];
            diasSemanas.forEach(d => calendarioGrid.innerHTML += `<div class="dia-semana">${d}</div>`);
            
            const diasMesAnterior = 5; 
            const diasEnMes = 31;
            
            for(let i=0; i<diasMesAnterior; i++) calendarioGrid.innerHTML += `<div class="dia-mes otro-mes"></div>`;
            for(let i=1; i<=diasEnMes; i++) calendarioGrid.innerHTML += `<div class="dia-mes" data-dia="${i}"><span class="numero-dia">${i}</span></div>`;
        };

        const cargarPlanes = () => {
            document.querySelectorAll('.dia-mes:not(.otro-mes)').forEach(dia => {
                const numeroDia = dia.dataset.dia;
                const clave = `plan-${mesAnioActual}-${numeroDia}`;
                const planGuardado = JSON.parse(localStorage.getItem(clave));

                const previewExistente = dia.querySelector('.plan-preview');
                if (previewExistente) previewExistente.remove();
                dia.classList.remove('con-plan');

                if (planGuardado && planGuardado.imagen) {
                    const previewDiv = document.createElement('div');
                    previewDiv.classList.add('plan-preview');
                    previewDiv.style.backgroundImage = `url('${planGuardado.imagen}')`;
                    dia.appendChild(previewDiv);
                    dia.classList.add('con-plan');
                }
            });
        };
        
        const abrirModalEdicion = () => {
            const numeroDia = diaSeleccionado.dataset.dia;
            document.getElementById('editModalTitle').textContent = `Plan para el día ${numeroDia}`;
            const clave = `plan-${mesAnioActual}-${numeroDia}`;
            const planGuardado = JSON.parse(localStorage.getItem(clave));

            planForm.reset();
            imagePreview.style.display = 'none';
            imagenBase64 = null;

            if (planGuardado) {
                document.getElementById('planText').value = planGuardado.texto || '';
                if(planGuardado.imagen){
                    imagePreview.src = planGuardado.imagen;
                    imagePreview.style.display = 'block';
                    imagenBase64 = planGuardado.imagen;
                }
            }
            editModal.classList.add('visible');
        };
        
        const abrirModalVisualizacion = (plan) => {
            const numeroDia = diaSeleccionado.dataset.dia;
            document.getElementById('viewModalTitle').textContent = `Plan del día ${numeroDia}`;
            document.getElementById('viewImage').style.backgroundImage = plan.imagen ? `url('${plan.imagen}')` : 'none';
            document.getElementById('viewText').textContent = plan.texto;
            viewModal.classList.add('visible');
        };

        imageUpload.addEventListener('change', event => {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = e => {
                    imagenBase64 = e.target.result;
                    imagePreview.src = imagenBase64;
                    imagePreview.style.display = 'block';
                };
                reader.readAsDataURL(file);
            }
        });
        
        planForm.addEventListener('submit', event => {
            event.preventDefault();
            const clave = `plan-${mesAnioActual}-${diaSeleccionado.dataset.dia}`;
            const plan = {
                imagen: imagenBase64,
                texto: document.getElementById('planText').value
            };
            if (!plan.imagen && !plan.texto) {
                localStorage.removeItem(clave);
            } else {
                localStorage.setItem(clave, JSON.stringify(plan));
            }
            cargarPlanes();
            cerrarModales();
        });

        borrarPlanBtn.addEventListener('click', () => {
            const clave = `plan-${mesAnioActual}-${diaSeleccionado.dataset.dia}`;
            localStorage.removeItem(clave);
            cargarPlanes();
            cerrarModales();
        });

        document.getElementById('editarPlan').addEventListener('click', () => {
            viewModal.classList.remove('visible');
            abrirModalEdicion();
        });

        const cerrarModales = () => {
            document.querySelectorAll('.modal-background').forEach(modal => modal.classList.remove('visible'));
        };

        generarCalendario();
        document.querySelectorAll('.dia-mes:not(.otro-mes)').forEach(dia => {
            dia.addEventListener('click', () => {
                diaSeleccionado = dia;
                const clave = `plan-${mesAnioActual}-${dia.dataset.dia}`;
                const planGuardado = JSON.parse(localStorage.getItem(clave));
                if (planGuardado && (planGuardado.imagen || planGuardado.texto)) {
                    abrirModalVisualizacion(planGuardado);
                } else {
                    abrirModalEdicion();
                }
            });
        });

        document.querySelectorAll('.modal-close').forEach(btn => btn.addEventListener('click', cerrarModales));
        document.querySelectorAll('.modal-background').forEach(modal => {
            modal.addEventListener('click', e => { if (e.target === modal) cerrarModales(); });
        });
        document.addEventListener('keydown', e => { if (e.key === 'Escape') cerrarModales(); });
        
        cargarPlanes();

        // --- LÓGICA DEL JUEGO DE SNAKE ---
        const snakeBoard = document.getElementById('snake-game-board');
        const snakeCtx = snakeBoard.getContext('2d');
        const snakeScoreDisplay = document.getElementById('snake-score');
        const snakeGameOverText = document.getElementById('snake-gameOverText');
        
        const snakeUpBtn = document.getElementById('snake-up-btn');
        const snakeDownBtn = document.getElementById('snake-down-btn');
        const snakeLeftBtn = document.getElementById('snake-left-btn');
        const snakeRightBtn = document.getElementById('snake-right-btn');
        
        const snakeGridSize = 20;
        let snake = [{ x: 10, y: 10, angle: 0 }]; 
        let snakeApples = []; // Array para almacenar múltiples manzanas
        let snakeDx = 0, snakeDy = 0;
        let snakeScore = 0;
        let isSnakeGameOver = false;
        let snakeGameLoop;
        
        let snakeInitialTickRate = 150; 
        let snakeTickRate = snakeInitialTickRate; 
        let lastMoveTime = 0;
        let appleCount = 0; 
        const SPEED_INCREASE_INTERVAL = 20; 
        const SPEED_DECREASE_AMOUNT = 20; 
        const ROTATION_SPEED = Math.PI / 10; 
        const SCORE_FOR_TWO_APPLES = 50; 

        const toRadians = (angle) => angle * (Math.PI / 180);

        const generarSnakeManzana = () => {
            let newApplePos;
            do {
                newApplePos = {
                    x: Math.floor(Math.random() * (snakeBoard.width / snakeGridSize)),
                    y: Math.floor(Math.random() * (snakeBoard.height / snakeGridSize))
                };
            } while (snake.some(part => part.x === newApplePos.x && part.y === newApplePos.y) || 
                     snakeApples.some(apple => apple.x === newApplePos.x && apple.y === newApplePos.y));
            return newApplePos;
        };
        
        const dibujarSnake = () => {
            snakeCtx.clearRect(0, 0, snakeBoard.width, snakeBoard.height);
            snakeCtx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--snake-bg');
            snakeCtx.fillRect(0, 0, snakeBoard.width, snakeBoard.height);
            
            const segmentSize = snakeGridSize;
            const segmentRadius = segmentSize / 2;

            snakeCtx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--snake-color');
            snakeCtx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--snake-color');

            // Dibuja el cuerpo de la serpiente
            for (let i = snake.length - 1; i > 0; i--) {
                const currentSegment = snake[i];
                const prevSegment = snake[i - 1];

                const currentX = currentSegment.x * segmentSize + segmentRadius;
                const currentY = currentSegment.y * segmentSize + segmentRadius;
                const prevX = prevSegment.x * segmentSize + segmentRadius;
                const prevY = prevSegment.y * segmentSize + segmentRadius;

                snakeCtx.beginPath();
                snakeCtx.moveTo(prevX, prevY);
                snakeCtx.lineTo(currentX, currentY);
                snakeCtx.lineCap = 'round';
                snakeCtx.lineJoin = 'round';
                snakeCtx.lineWidth = segmentSize;
                snakeCtx.stroke();
            }

            // Dibuja la cabeza con rotación
            const head = snake[0];
            const headCenterX = head.x * segmentSize + segmentRadius;
            const headCenterY = head.y * segmentSize + segmentRadius;

            snakeCtx.save(); 
            snakeCtx.translate(headCenterX, headCenterY);
            snakeCtx.rotate(head.angle); 
            snakeCtx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--snake-color');
            snakeCtx.beginPath();
            snakeCtx.arc(0, 0, segmentRadius, 0, Math.PI * 2); 
            snakeCtx.fill();

            // Dibuja los ojos (siempre "hacia adelante" en la cabeza)
            snakeCtx.fillStyle = 'white';
            const eyeSize = segmentRadius * 0.3;
            const pupilSize = eyeSize * 0.5;
            const eyeOffset = segmentRadius * 0.3;

            // Ojo derecho (relativo al frente de la cabeza rotada)
            snakeCtx.beginPath();
            snakeCtx.arc(segmentRadius * 0.5, -eyeOffset, eyeSize, 0, Math.PI * 2); 
            snakeCtx.fill();
            snakeCtx.fillStyle = 'black';
            snakeCtx.beginPath();
            snakeCtx.arc(segmentRadius * 0.5, -eyeOffset, pupilSize, 0, Math.PI * 2);
            snakeCtx.fill();

            // Ojo izquierdo (relativo al frente de la cabeza rotada)
            snakeCtx.fillStyle = 'white';
            snakeCtx.beginPath();
            snakeCtx.arc(segmentRadius * 0.5, eyeOffset, eyeSize, 0, Math.PI * 2); 
            snakeCtx.fill();
            snakeCtx.fillStyle = 'black';
            snakeCtx.beginPath();
            snakeCtx.arc(segmentRadius * 0.5, eyeOffset, pupilSize, 0, Math.PI * 2);
            snakeCtx.fill();

            snakeCtx.restore(); 
            
            // Dibuja las manzanas
            snakeApples.forEach(apple => {
                const appleCenterX = apple.x * segmentSize + segmentRadius;
                const appleCenterY = apple.y * segmentSize + segmentRadius;

                snakeCtx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--apple-color');
                snakeCtx.beginPath();
                snakeCtx.arc(appleCenterX, appleCenterY, segmentRadius * 0.8, 0, Math.PI * 2); 
                snakeCtx.fill();
                snakeCtx.strokeStyle = 'rgba(0,0,0,0.2)'; 
                snakeCtx.lineWidth = 1;
                snakeCtx.stroke();

                snakeCtx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--apple-leaf-color');
                snakeCtx.beginPath();
                const leafX = appleCenterX + segmentRadius * 0.3;
                const leafY = appleCenterY - segmentRadius * 0.7;
                snakeCtx.ellipse(leafX, leafY, segmentRadius * 0.3, segmentRadius * 0.15, -Math.PI / 4, 0, Math.PI * 2);
                snakeCtx.fill();
            });
        };

        const moverSnakeSerpiente = () => {
            if (isSnakeGameOver) return;

            // Calcular el nuevo ángulo objetivo para la dirección de movimiento
            let targetAngle;
            if (snakeDx === 1) targetAngle = 0; // Derecha (0 radianes)
            else if (snakeDx === -1) targetAngle = Math.PI; // Izquierda (PI radianes)
            else if (snakeDy === 1) targetAngle = Math.PI / 2; // Abajo (PI/2 radianes)
            else targetAngle = -Math.PI / 2; // Arriba (-PI/2 radianes)

            let head = snake[0];
            let currentHeadAngle = head.angle;
            let angleDiff = targetAngle - currentHeadAngle;

            // Normalizar la diferencia de ángulo para el giro más corto
            if (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
            if (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;

            // Aplicar rotación gradual a la cabeza
            if (Math.abs(angleDiff) > ROTATION_SPEED) {
                head.angle += Math.sign(angleDiff) * ROTATION_SPEED;
            } else {
                head.angle = targetAngle; 
            }
            // Asegurarse de que el ángulo esté en el rango [0, 2PI)
            head.angle = (head.angle + 2 * Math.PI) % (2 * Math.PI);

            // Mover la cabeza a la nueva posición de cuadrícula
            const newHeadX = head.x + snakeDx;
            const newHeadY = head.y + snakeDy;

            const newHead = { x: newHeadX, y: newHeadY, angle: head.angle };
            snake.unshift(newHead); // Añadir nueva cabeza

            let ateApple = false;
            for (let i = 0; i < snakeApples.length; i++) {
                if (newHeadX === snakeApples[i].x && newHeadY === snakeApples[i].y) {
                    snakeScore++;
                    appleCount++;
                    snakeScoreDisplay.textContent = snakeScore;
                    
                    snakeApples.splice(i, 1); // Remover la manzana comida
                    snakeApples.push(generarSnakeManzana()); // Generar una nueva

                    if (snakeScore >= SCORE_FOR_TWO_APPLES && snakeApples.length < 2) {
                        snakeApples.push(generarSnakeManzana()); // Añadir segunda manzana si el score lo permite
                    }

                    if (appleCount % SPEED_INCREASE_INTERVAL === 0) {
                        snakeTickRate = Math.max(50, snakeTickRate - SPEED_DECREASE_AMOUNT); 
                        console.log("Velocidad Snake aumentada. Nuevo tickRate:", snakeTickRate);
                    }
                    ateApple = true;
                    break;
                }
            }

            if (!ateApple) {
                snake.pop(); // Eliminar la cola si no come manzana
            }

            // Propagar los ángulos a lo largo del cuerpo (para el efecto de giro del cuerpo)
            for (let i = 1; i < snake.length; i++) {
                snake[i].angle = snake[i-1].angle;
            }
        };

        const chequearSnakeColision = () => {
            const cabeza = snake[0];
            if (cabeza.x < 0 || cabeza.x >= snakeBoard.width / snakeGridSize || cabeza.y < 0 || cabeza.y >= snakeBoard.height / snakeGridSize) {
                return true; 
            }
            for (let i = 1; i < snake.length; i++) {
                if (cabeza.x === snake[i].x && cabeza.y === snake[i].y) return true; 
            }
            return false;
        };

        const mainSnakeLoop = (currentTime) => {
            if (isSnakeGameOver) {
                return;
            }

            snakeGameLoop = requestAnimationFrame(mainSnakeLoop);

            if (currentTime - lastMoveTime > snakeTickRate) {
                lastMoveTime = currentTime;
                moverSnakeSerpiente();
                if (chequearSnakeColision()) {
                    isSnakeGameOver = true;
                    snakeGameOverText.style.display = 'block';
                    cancelAnimationFrame(snakeGameLoop);
                    return;
                }
            }
            dibujarSnake();
        };
        
        let changingDirection = false; 

        const cambiarSnakeDireccion = (direccion) => {
            if (isSnakeGameOver || changingDirection) return;
            changingDirection = true; 
            setTimeout(() => changingDirection = false, snakeTickRate);

            const ARRIBA = snakeDy === -1;
            const ABAJO = snakeDy === 1;
            const DERECHA = snakeDx === 1;
            const IZQUIERDA = snakeDx === -1;

            let newDx = snakeDx;
            let newDy = snakeDy;

            if ((direccion === "up") && !ABAJO) { newDx = 0; newDy = -1; }
            if ((direccion === "down") && !ARRIBA) { newDx = 0; newDy = 1; }
            if ((direccion === "left") && !DERECHA) { newDx = -1; newDy = 0; }
            if ((direccion === "right") && !IZQUIERDA) { newDx = 1; newDy = 0; }
            
            if (newDx !== snakeDx || newDy !== snakeDy) {
                snakeDx = newDx;
                snakeDy = newDy;
            }
        };

        const iniciarSnakeGame = () => {
            snake = [{ x: 10, y: 10, angle: toRadians(0) }];
            snakeDx = 1; snakeDy = 0; 
            snakeScore = 0;
            appleCount = 0;
            snakeTickRate = snakeInitialTickRate;
            snakeScoreDisplay.textContent = snakeScore;
            isSnakeGameOver = false;
            snakeGameOverText.style.display = 'none';
            
            snakeApples = []; // Limpiar manzanas existentes
            snakeApples.push(generarSnakeManzana()); // Generar la primera manzana
            
            lastMoveTime = performance.now();
            cancelAnimationFrame(snakeGameLoop);
            snakeGameLoop = requestAnimationFrame(mainSnakeLoop); 
        };

        document.addEventListener('keydown', e => {
            if (currentGame !== 'snake' || isSnakeGameOver) return;
            const key = e.key;
            if (key === 'ArrowUp' || key === 'w') cambiarSnakeDireccion('up');
            if (key === 'ArrowDown' || key === 's') cambiarSnakeDireccion('down');
            if (key === 'ArrowLeft' || key === 'a') cambiarSnakeDireccion('left');
            if (key === 'ArrowRight' || key === 'd') cambiarSnakeDireccion('right');
        });

        snakeUpBtn.addEventListener('click', () => cambiarSnakeDireccion('up'));
        snakeDownBtn.addEventListener('click', () => cambiarSnakeDireccion('down'));
        snakeLeftBtn.addEventListener('click', () => cambiarSnakeDireccion('left'));
        snakeRightBtn.addEventListener('click', () => cambiarSnakeDireccion('right'));


        // --- LÓGICA DEL JUEGO DE TETRIS ---
        const tetrisCanvas = document.getElementById('tetris-canvas');
        const tetrisCtx = tetrisCanvas.getContext('2d');
        const tetrisNextPieceCanvas = document.getElementById('tetris-next-piece-canvas');
        const tetrisNextCtx = tetrisNextPieceCanvas.getContext('2d');
        const tetrisScoreDisplay = document.getElementById('tetris-score');
        const tetrisLevelDisplay = document.getElementById('tetris-level');
        const tetrisGameOverText = document.getElementById('tetris-gameOverText');

        document.getElementById('tetris-rotate-left').addEventListener('click', () => { if (!isTetrisGameOver) tetrisRotatePiece(-1); });
        document.getElementById('tetris-rotate-right').addEventListener('click', () => { if (!isTetrisGameOver) tetrisRotatePiece(1); });
        document.getElementById('tetris-move-left').addEventListener('click', () => { if (!isTetrisGameOver) tetrisMovePiece(-1, 0); });
        document.getElementById('tetris-move-right').addEventListener('click', () => { if (!isTetrisGameOver) tetrisMovePiece(1, 0); });
        document.getElementById('tetris-soft-drop').addEventListener('click', () => { if (!isTetrisGameOver) tetrisSoftDrop(); });
        document.getElementById('tetris-hard-drop').addEventListener('click', () => { if (!isTetrisGameOver) tetrisHardDrop(); });


        const TETRIS_ROWS = 20;
        const TETRIS_COLS = 10;
        const TETRIS_BLOCK_SIZE = tetrisCanvas.width / TETRIS_COLS; 
        const TETRIS_COLORS = [
            null, 
            '#FF0D72', 
            '#0DC2FF', 
            '#0DFF72', 
            '#F538FF', 
            '#FF8E0D', 
            '#FFE138', 
            '#3877FF'
        ];

        let tetrisBoard = [];
        let tetrisCurrentPiece;
        let tetrisNextPiece;
        let tetrisScore = 0;
        let tetrisLevel = 1;
        let tetrisDropInterval = 1000; 
        let tetrisGameLoop;
        let isTetrisGameOver = false;

        const TETROMINOS = {
            'I': [[0,0,0,0], [1,1,1,1], [0,0,0,0], [0,0,0,0]], 
            'J': [[2,0,0], [2,2,2], [0,0,0]], 
            'L': [[0,0,3], [3,3,3], [0,0,0]], 
            'O': [[4,4], [4,4]], 
            'S': [[0,5,5], [5,5,0], [0,0,0]], 
            'T': [[0,6,0], [6,6,6], [0,0,0]], 
            'Z': [[7,7,0], [0,7,7], [0,0,0]]  
        };

        const TETROMINO_KEYS = Object.keys(TETROMINOS);

        function tetrisCreateBoard() {
            tetrisBoard = Array(TETRIS_ROWS).fill(0).map(() => Array(TETRIS_COLS).fill(0));
        }

        function tetrisGenerateRandomPiece() {
            const randKey = TETROMINO_KEYS[Math.floor(Math.random() * TETROMINO_KEYS.length)];
            const shape = TETROMINOS[randKey];
            const colorIndex = TETROMINO_KEYS.indexOf(randKey) + 1;
            return {
                shape: shape,
                color: colorIndex,
                x: Math.floor(TETRIS_COLS / 2) - Math.floor(shape[0].length / 2),
                y: 0
            };
        }

        function tetrisDrawBlock(ctx, x, y, color) {
            if (color === 0) return; 
            ctx.fillStyle = TETRIS_COLORS[color];
            ctx.fillRect(x * TETRIS_BLOCK_SIZE, y * TETRIS_BLOCK_SIZE, TETRIS_BLOCK_SIZE, TETRIS_BLOCK_SIZE);
            ctx.strokeStyle = '#222';
            ctx.strokeRect(x * TETRIS_BLOCK_SIZE, y * TETRIS_BLOCK_SIZE, TETRIS_BLOCK_SIZE, TETRIS_BLOCK_SIZE);
        }

        function tetrisDrawBoard() {
            for (let r = 0; r < TETRIS_ROWS; r++) {
                for (let c = 0; c < TETRIS_COLS; c++) {
                    tetrisDrawBlock(tetrisCtx, c, r, tetrisBoard[r][c]);
                }
            }
        }

        function tetrisDrawPiece(ctx, piece) {
            piece.shape.forEach((row, r) => {
                row.forEach((value, c) => {
                    if (value !== 0) {
                        tetrisDrawBlock(ctx, piece.x + c, piece.y + r, piece.color);
                    }
                });
            });
        }

        function tetrisDrawNextPiece() {
            tetrisNextCtx.clearRect(0, 0, tetrisNextPieceCanvas.width, tetrisNextPieceCanvas.height);
            tetrisNextCtx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--tetris-score-bg');
            tetrisNextCtx.fillRect(0,0, tetrisNextPieceCanvas.width, tetrisNextPieceCanvas.height);

            const nextBlockSize = tetrisNextPieceCanvas.width / 4; 
            const piece = tetrisNextPiece;
            const startX = (tetrisNextPieceCanvas.width - piece.shape[0].length * nextBlockSize) / 2 / nextBlockSize;
            const startY = (tetrisNextPieceCanvas.height - piece.shape.length * nextBlockSize) / 2 / nextBlockSize;

            piece.shape.forEach((row, r) => {
                row.forEach((value, c) => {
                    if (value !== 0) {
                        tetrisNextCtx.fillStyle = TETRIS_COLORS[piece.color];
                        tetrisNextCtx.fillRect((startX + c) * nextBlockSize, (startY + r) * nextBlockSize, nextBlockSize, nextBlockSize);
                        tetrisNextCtx.strokeStyle = '#222';
                        tetrisNextCtx.strokeRect((startX + c) * nextBlockSize, (startY + r) * nextBlockSize, nextBlockSize, nextBlockSize);
                    }
                });
            });
        }

        function tetrisCheckCollision(piece, offsetX, offsetY) {
            for (let r = 0; r < piece.shape.length; r++) {
                for (let c = 0; c < piece.shape[r].length; c++) {
                    if (piece.shape[r][c] !== 0) {
                        const newX = piece.x + c + offsetX;
                        const newY = piece.y + r + offsetY;

                        if (newX < 0 || newX >= TETRIS_COLS || newY >= TETRIS_ROWS) {
                            return true; 
                        }
                        if (newY < 0) { 
                            continue;
                        }
                        if (tetrisBoard[newY][newX] !== 0) {
                            return true; 
                        }
                    }
                }
            }
            return false;
        }

        function tetrisMergePiece() {
            tetrisCurrentPiece.shape.forEach((row, r) => {
                row.forEach((value, c) => {
                    if (value !== 0) {
                        tetrisBoard[tetrisCurrentPiece.y + r][tetrisCurrentPiece.x + c] = tetrisCurrentPiece.color;
                    }
                });
            });
        }

        function tetrisClearLines() {
            let linesCleared = 0;
            for (let r = TETRIS_ROWS - 1; r >= 0; r--) {
                if (tetrisBoard[r].every(cell => cell !== 0)) {
                    linesCleared++;
                    tetrisBoard.splice(r, 1); 
                    tetrisBoard.unshift(Array(TETRIS_COLS).fill(0)); 
                    r++; 
                }
            }
            if (linesCleared > 0) {
                tetrisScore += [0, 100, 300, 500, 800][linesCleared]; 
                tetrisScoreDisplay.textContent = tetrisScore;
                
                const newLevel = Math.floor(tetrisScore / 1000) + 1; 
                if (newLevel > tetrisLevel) {
                    tetrisLevel = newLevel;
                    tetrisLevelDisplay.textContent = tetrisLevel;
                    tetrisDropInterval = Math.max(100, tetrisDropInterval - 50); 
                    clearInterval(tetrisGameLoop);
                    tetrisGameLoop = setInterval(tetrisMainLoop, tetrisDropInterval);
                }
            }
        }

        function tetrisMovePiece(dx, dy) {
            if (!tetrisCheckCollision(tetrisCurrentPiece, dx, dy)) {
                tetrisCurrentPiece.x += dx;
                tetrisCurrentPiece.y += dy;
                tetrisDrawGame();
                return true;
            }
            return false;
        }

        function tetrisRotatePiece(direction) { 
            const originalShape = tetrisCurrentPiece.shape;
            const rotatedShape = Array(originalShape[0].length).fill(0).map(() => Array(originalShape.length).fill(0));
            
            if (direction === 1) { 
                for (let r = 0; r < originalShape.length; r++) {
                    for (let c = 0; c < originalShape[r].length; c++) {
                        rotatedShape[c][originalShape.length - 1 - r] = originalShape[r][c];
                    }
                }
            } else { 
                 for (let r = 0; r < originalShape.length; r++) {
                    for (let c = 0; c < originalShape[r].length; c++) {
                        rotatedShape[originalShape[r].length - 1 - c][r] = originalShape[r][c];
                    }
                }
            }

            const originalX = tetrisCurrentPiece.x;
            const originalY = tetrisCurrentPiece.y;
            tetrisCurrentPiece.shape = rotatedShape;

            const kicks = [0, -1, 1, -2, 2]; 
            for (let i = 0; i < kicks.length; i++) {
                tetrisCurrentPiece.x = originalX + kicks[i];
                if (!tetrisCheckCollision(tetrisCurrentPiece, 0, 0)) {
                    tetrisDrawGame();
                    return;
                }
            }
            
            tetrisCurrentPiece.shape = originalShape;
            tetrisCurrentPiece.x = originalX;
            tetrisCurrentPiece.y = originalY;
        }

        function tetrisSoftDrop() {
            tetrisMovePiece(0, 1);
        }

        function tetrisHardDrop() {
            while (tetrisMovePiece(0, 1)) { }
            tetrisLockPiece();
        }

        function tetrisLockPiece() {
            tetrisMergePiece();
            tetrisClearLines();
            tetrisCurrentPiece = tetrisNextPiece;
            tetrisNextPiece = tetrisGenerateRandomPiece();
            tetrisDrawNextPiece();

            if (tetrisCheckCollision(tetrisCurrentPiece, 0, 0)) {
                isTetrisGameOver = true;
                clearInterval(tetrisGameLoop);
                tetrisGameOverText.style.display = 'block';
                tetrisCtx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                tetrisCtx.fillRect(0, 0, tetrisCanvas.width, tetrisCanvas.height);
            }
            tetrisDrawGame();
        }

        function tetrisMainLoop() {
            if (isTetrisGameOver) return;
            if (!tetrisMovePiece(0, 1)) { 
                tetrisLockPiece();
            }
            tetrisDrawGame();
        }

        function tetrisDrawGame() {
            tetrisCtx.clearRect(0, 0, tetrisCanvas.width, tetrisCanvas.height);
            tetrisCtx.fillStyle = '#000'; 
            tetrisCtx.fillRect(0, 0, tetrisCanvas.width, tetrisCanvas.height);
            tetrisDrawBoard();
            tetrisDrawPiece(tetrisCtx, tetrisCurrentPiece);
        }

        function iniciarTetrisGame() {
            tetrisCreateBoard();
            tetrisScore = 0;
            tetrisLevel = 1;
            tetrisDropInterval = 1000;
            isTetrisGameOver = false;
            tetrisScoreDisplay.textContent = tetrisScore;
            tetrisLevelDisplay.textContent = tetrisLevel;
            tetrisGameOverText.style.display = 'none';
            tetrisCurrentPiece = tetrisGenerateRandomPiece();
            tetrisNextPiece = tetrisGenerateRandomPiece();
            tetrisDrawNextPiece();
            clearInterval(tetrisGameLoop);
            tetrisGameLoop = setInterval(tetrisMainLoop, tetrisDropInterval);
            tetrisDrawGame();
        }

        document.addEventListener('keydown', e => {
            if (currentGame !== 'tetris' || isTetrisGameOver) return;

            switch (e.key) {
                case 'ArrowLeft':
                case 'a':
                    tetrisMovePiece(-1, 0);
                    break;
                case 'ArrowRight':
                case 'd':
                    tetrisMovePiece(1, 0);
                    break;
                case 'ArrowDown':
                case 's':
                    tetrisSoftDrop();
                    break;
                case 'ArrowUp':
                case 'w':
                    tetrisRotatePiece(1); 
                    break;
                case ' ': 
                    e.preventDefault(); 
                    tetrisHardDrop();
                    break;
                case 'z': 
                    tetrisRotatePiece(-1);
                    break;
                case 'r': 
                    if(isTetrisGameOver) iniciarTetrisGame();
                    break;
            }
        });
        
        showView('planner');
    });
    </script>
</body>
</html>
